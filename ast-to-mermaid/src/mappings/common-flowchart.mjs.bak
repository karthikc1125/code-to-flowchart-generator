import { createFlowBuilder } from './_common.mjs';

// Common flowchart generation logic that works for any language
export function generateCommonFlowchart(nodes, languageConfig) {
  try {
    const flow = createFlowBuilder();
    const start = flow.addStart();
    let last = start;

    // Find the root node (program, module, etc.)
    // nodes may be a generator; normalize to an array first
    const nodeList = Array.isArray(nodes) ? nodes : Array.from(nodes || []);
    const rootNode = nodeList.find(n => n && languageConfig.rootNodeTypes.includes(n.type));
    if (!rootNode || !rootNode.children) {
      const end = flow.addEnd();
      flow.link(start, end);
      return flow.toString();
    }

    // First, process user-defined functions and create subgraphs for them
    const functionNodes = nodeList.filter(n => languageConfig.isFunctionDefinition && languageConfig.isFunctionDefinition(n));
    for (const funcNode of functionNodes) {
      const funcName = languageConfig.extractFunctionName ? languageConfig.extractFunctionName(funcNode) : 'function';
      const subgraphId = flow.beginSubgraph(funcNode, `Function: ${funcName}`);
      
      // Process the function body
      const funcBody = funcNode.children.find(c => c && (c.type === 'statement_block' || c.type === 'compound_statement' || c.type === 'block'));
      if (funcBody && funcBody.children) {
        const funcStatements = funcBody.children;
        processStatements(funcStatements, flow, languageConfig, null);
      }
      
      flow.endSubgraph();
    }

    // Determine which nodes to process. Allow language to provide a focused list (e.g., main method body)
    const candidateNodesRaw = typeof languageConfig.findStatementNodes === 'function'
      ? (languageConfig.findStatementNodes(rootNode) || [])
      : (rootNode.children || []);
    const candidateNodes = Array.isArray(candidateNodesRaw) ? candidateNodesRaw : Array.from(candidateNodesRaw || []);

    const processedNodes = new Set();
    
    // Process all candidate nodes
    last = processStatements(candidateNodes, flow, languageConfig, processedNodes);
    
    // Create end node and finalize all connections
    const end = flow.addEnd();
    if (last !== start) {
      flow.link(last, end);
    } else {
      flow.link(start, end);
    }
    flow.finalize(end);
    
    return flow.toString();
  } catch (error) {
    console.error('Error in common flowchart generation:', error);
    return 'flowchart TD\nA([start])\nB([end])\nA --> B';
  }
}

// Function to process a list of statements
function processStatements(statements, flow, languageConfig, processedNodes) {
  let last = 'start'; // This will be updated as we process statements
  
  for (const node of statements) {
    if (!node) continue;
    if (processedNodes && processedNodes.has(node)) continue;
    
    try {
        // Handle variable declarations and assignments
        if (languageConfig.isAssignment && languageConfig.isAssignment(node)) {
          const varInfo = languageConfig.extractVariableInfo ? languageConfig.extractVariableInfo(node) : null;
          if (varInfo && (varInfo.name || varInfo.value)) {
            const label = `${varInfo.name ?? ''} = ${varInfo.value ?? ''}`.trim();
            const assignId = flow.addAction(node, label);
            flow.link(last, assignId);
            last = assignId;
            processedNodes.add(node);
            continue;
          }
        }
      
        // Handle input operations
        if (languageConfig.isInputCall && languageConfig.isInputCall(node)) {
          const inputInfo = languageConfig.extractInputInfo ? languageConfig.extractInputInfo(node) : { prompt: '' };
          const label = inputInfo && inputInfo.prompt ? `read input: ${inputInfo.prompt}` : 'read input';
          const inputId = flow.addInputOutput(node, label);
          flow.link(last, inputId);
          last = inputId;
          processedNodes.add(node);
          continue;
        }
      
        // Handle conditional statements
        if (languageConfig.isConditional && languageConfig.isConditional(node)) {
          const condInfo = (languageConfig.extractConditionInfo && languageConfig.extractConditionInfo(node)) || { text: 'condition' };
          
          // Use different shapes for different conditional types
          let condId;
          if (node.type === 'if_statement') {
            condId = flow.addIfStatement(node, `${condInfo.text || 'condition'}?`);
          } else if (node.type === 'switch_statement') {
            condId = flow.addSwitchStatement(node, `${condInfo.text || 'condition'}?`);
          } else {
            condId = flow.addDecision(node, `${condInfo.text || 'condition'}?`);
          }
          
        flow.link(last, condId);
        
        // Process then branch
          const thenInfo = (languageConfig.extractThenBranch && languageConfig.extractThenBranch(node)) || { calls: [], statements: [] };
          const thenCalls = Array.isArray(thenInfo?.calls) ? thenInfo.calls : [];
          const thenStatements = Array.isArray(thenInfo?.statements) ? thenInfo.statements : [];
          
          if (thenCalls.length > 0 || thenStatements.length > 0) {
          let thenLast = condId;
          
          // Process calls within then branch
          for (const call of thenCalls) {
            if (languageConfig.isOutputCall && languageConfig.isOutputCall(call)) {
              const outputInfo = languageConfig.extractOutputInfo(call);
              if (outputInfo) {
                const label = outputInfo.arg ? `${outputInfo.function} ${outputInfo.arg}` : outputInfo.function;
                const outputId = flow.addInputOutput(call, label);
                flow.link(thenLast, outputId, thenLast === condId ? 'yes' : undefined);
                thenLast = outputId;
              }
            }
          }
          
          // If no specific calls were processed but statements exist, create a generic action
          if (thenLast === condId && thenStatements.length > 0) {
            const actionId = flow.addAction(thenStatements[0], 'execute then');
            flow.link(condId, actionId, 'yes');
            thenLast = actionId;
          }
          
          flow.linkToEnd(thenLast);
          } else {
            // Empty then branch, still show yes path
            flow.linkToEnd(condId, 'yes');
          }
        
        // Process else branch if exists
          const elseInfo = (languageConfig.extractElseBranch && languageConfig.extractElseBranch(node)) || { calls: [], statements: [] };
          const elseCalls = Array.isArray(elseInfo?.calls) ? elseInfo.calls : [];
          const elseStatements = Array.isArray(elseInfo?.statements) ? elseInfo.statements : [];
          
          // Check if this is an else-if statement (else clause containing another if_statement)
          let isElseIf = false;
          let elseIfNode = null;
          if (elseInfo && elseInfo.calls && elseInfo.calls.length === 0 && elseStatements.length === 0) {
            // Look for nested if_statement in the else clause
            const elseBlock = node.children.find(c => c && c.type === 'else_clause');
            if (elseBlock) {
              const nestedIf = elseBlock.children.find(c => c && c.type === 'if_statement');
              if (nestedIf) {
                isElseIf = true;
                elseIfNode = nestedIf;
              }
            }
          }
          
          if (isElseIf && elseIfNode) {
            // Handle else-if as a separate conditional node
            const elseIfCondInfo = (languageConfig.extractConditionInfo && languageConfig.extractConditionInfo(elseIfNode)) || { text: 'condition' };
            const elseIfId = flow.addElseIfStatement(elseIfNode, `${elseIfCondInfo.text || 'condition'}?`);
            flow.link(condId, elseIfId, 'no');
            
            // Process the else-if branch
            const elseIfThenInfo = (languageConfig.extractThenBranch && languageConfig.extractThenBranch(elseIfNode)) || { calls: [], statements: [] };
            const elseIfThenCalls = Array.isArray(elseIfThenInfo?.calls) ? elseIfThenInfo.calls : [];
            const elseIfThenStatements = Array.isArray(elseIfThenInfo?.statements) ? elseIfThenInfo.statements : [];
            
            if (elseIfThenCalls.length > 0 || elseIfThenStatements.length > 0) {
              let elseIfThenLast = elseIfId;
              
              // Process calls within else-if then branch
              for (const call of elseIfThenCalls) {
                if (languageConfig.isOutputCall && languageConfig.isOutputCall(call)) {
                  const outputInfo = languageConfig.extractOutputInfo(call);
                  if (outputInfo) {
                    const label = outputInfo.arg ? `${outputInfo.function} ${outputInfo.arg}` : outputInfo.function;
                    const outputId = flow.addInputOutput(call, label);
                    flow.link(elseIfThenLast, outputId, elseIfThenLast === elseIfId ? 'yes' : undefined);
                    elseIfThenLast = outputId;
                  }
                }
              }
              
              // If no specific calls were processed but statements exist, create a generic action
              if (elseIfThenLast === elseIfId && elseIfThenStatements.length > 0) {
                const actionId = flow.addAction(elseIfThenStatements[0], 'execute then');
                flow.link(elseIfId, actionId, 'yes');
                elseIfThenLast = actionId;
              }
              
              flow.linkToEnd(elseIfThenLast);
            } else {
              // Empty else-if then branch, still show yes path
              flow.linkToEnd(elseIfId, 'yes');
            }
            
            // Process the else branch of the else-if (if it exists)
            const elseIfElseInfo = (languageConfig.extractElseBranch && languageConfig.extractElseBranch(elseIfNode)) || { calls: [], statements: [] };
            const elseIfElseCalls = Array.isArray(elseIfElseInfo?.calls) ? elseIfElseInfo.calls : [];
            const elseIfElseStatements = Array.isArray(elseIfElseInfo?.statements) ? elseIfElseInfo.statements : [];
            
            if (elseIfElseCalls.length > 0 || elseIfElseStatements.length > 0) {
              let elseIfElseLast = elseIfId;
              
              // Process calls within else-if else branch
              for (const call of elseIfElseCalls) {
                if (languageConfig.isOutputCall && languageConfig.isOutputCall(call)) {
                  const outputInfo = languageConfig.extractOutputInfo(call);
                  if (outputInfo) {
                    const label = outputInfo.arg ? `${outputInfo.function} ${outputInfo.arg}` : outputInfo.function;
                    const outputId = flow.addInputOutput(call, label);
                    flow.link(elseIfElseLast, outputId, elseIfElseLast === elseIfId ? 'no' : undefined);
                    elseIfElseLast = outputId;
                  }
                }
              }
              
              // If no specific calls were processed but statements exist, create a generic action
              if (elseIfElseLast === elseIfId && elseIfElseStatements.length > 0) {
                const actionId = flow.addAction(elseIfElseStatements[0], 'execute else');
                flow.link(elseIfId, actionId, 'no');
                elseIfElseLast = actionId;
              }
              
              flow.linkToEnd(elseIfElseLast);
            } else {
              // No else branch for else-if, connect to end with 'no' label
              flow.linkToEnd(elseIfId, 'no');
            }
          } else if (elseCalls.length > 0 || elseStatements.length > 0) {
          let elseLast = condId;
          
          // Process calls within else branch
          for (const call of elseCalls) {
            if (languageConfig.isOutputCall && languageConfig.isOutputCall(call)) {
              const outputInfo = languageConfig.extractOutputInfo(call);
              if (outputInfo) {
                const label = outputInfo.arg ? `${outputInfo.function} ${outputInfo.arg}` : outputInfo.function;
                const outputId = flow.addInputOutput(call, label);
                flow.link(elseLast, outputId, elseLast === condId ? 'no' : undefined);
                elseLast = outputId;
              }
            }
          }
          
          // If no specific calls were processed but statements exist, create a generic action
          if (elseLast === condId && elseStatements.length > 0) {
            const actionId = flow.addAction(elseStatements[0], 'execute else');
            flow.link(condId, actionId, 'no');
            elseLast = actionId;
          }
          
          flow.linkToEnd(elseLast);
          } else {
          // No else branch, connect condition to end with 'no' label
          flow.linkToEnd(condId, 'no');
          }
        
          processedNodes.add(node);
          last = condId;
          continue;
        }
      
        // Handle loops
        if (languageConfig.isLoop && languageConfig.isLoop(node)) {
          const loopInfo = (languageConfig.extractLoopInfo && languageConfig.extractLoopInfo(node)) || { type: 'loop', condition: 'condition', calls: [], statements: [] };
          const loopId = flow.addLoopStatement(node, `${loopInfo.type || 'loop'}: ${loopInfo.condition || 'condition'}`);
        flow.link(last, loopId);
        
        // Process loop body
          const loopCalls = Array.isArray(loopInfo?.calls) ? loopInfo.calls : [];
          const loopStatements = Array.isArray(loopInfo?.statements) ? loopInfo.statements : [];
          
          if (loopCalls.length > 0 || loopStatements.length > 0) {
          let bodyLast = loopId;
          
          // Process calls in loop body
          for (const call of loopCalls) {
            if (languageConfig.isOutputCall && languageConfig.isOutputCall(call)) {
              const outputInfo = languageConfig.extractOutputInfo(call);
              if (outputInfo) {
                const label = outputInfo.arg ? `${outputInfo.function} ${outputInfo.arg}` : outputInfo.function;
                const outputId = flow.addInputOutput(call, label);
                flow.link(bodyLast, outputId, bodyLast === loopId ? 'yes' : undefined);
                bodyLast = outputId;
              }
            }
          }
          
          // If no calls but statements exist, create generic action
          if (bodyLast === loopId && loopStatements.length > 0) {
            const actionId = flow.addAction(loopStatements[0], 'loop body');
            flow.link(loopId, actionId, 'yes');
            bodyLast = actionId;
          }
          
          // Loop back to condition
          flow.link(bodyLast, loopId);
          }
        
        // Connect loop exit to end with 'no' label
        flow.linkToEnd(loopId, 'no');
        
          processedNodes.add(node);
          last = loopId;
          continue;
        }
      
        // Handle output operations
        if (languageConfig.isOutputCall && languageConfig.isOutputCall(node)) {
          const outputInfo = languageConfig.extractOutputInfo ? languageConfig.extractOutputInfo(node) : null;
          if (outputInfo) {
            const label = outputInfo.arg ? `${outputInfo.function} ${outputInfo.arg}` : outputInfo.function;
            const outputId = flow.addInputOutput(node, label);
            flow.link(last, outputId);
            last = outputId;
            processedNodes.add(node);
            continue;
          }
        }
        
        // Handle return statements
        if (languageConfig.isReturnStatement && languageConfig.isReturnStatement(node)) {
          const returnInfo = languageConfig.extractReturnInfo ? languageConfig.extractReturnInfo(node) : { value: '' };
          const label = returnInfo.value ? `return ${returnInfo.value}` : 'return';
          const returnId = flow.addReturnStatement(node, label);
          flow.link(last, returnId);
          flow.linkToEnd(returnId);
          processedNodes.add(node);
          continue;
        }
        
        // Handle break statements
        if (languageConfig.isBreakStatement && languageConfig.isBreakStatement(node)) {
          const breakId = flow.addBreakStatement(node, 'break');
          flow.link(last, breakId);
          flow.linkToEnd(breakId);
          processedNodes.add(node);
          continue;
        }
        
        // Handle continue statements
        if (languageConfig.isContinueStatement && languageConfig.isContinueStatement(node)) {
          const continueId = flow.addContinueStatement(node, 'continue');
          flow.link(last, continueId);
          // For continue statements, we link back to the loop condition
          // This is a simplification - in reality, we'd need to track the enclosing loop
          flow.linkToEnd(continueId);
          processedNodes.add(node);
          continue;
        }
        
        // Handle generic function calls (not input/output)
        if (languageConfig.isFunctionCall && languageConfig.isFunctionCall(node)) {
          const callInfo = languageConfig.extractFunctionCallInfo ? languageConfig.extractFunctionCallInfo(node) : null;
          if (callInfo && callInfo.name) {
            const label = callInfo.args ? `${callInfo.name}(${callInfo.args})` : `${callInfo.name}()`;
            const callId = flow.addAction(node, label);
            flow.link(last, callId);
            last = callId;
            processedNodes.add(node);
            continue;
          }
        }
        
        // Handle expression statements that contain function calls
        if (node.type === 'expression_statement' && node.children) {
          const callExpr = node.children.find(c => c && c.type === 'call_expression');
          if (callExpr && languageConfig.isFunctionCall && languageConfig.isFunctionCall(callExpr)) {
            const callInfo = languageConfig.extractFunctionCallInfo ? languageConfig.extractFunctionCallInfo(callExpr) : null;
            if (callInfo && callInfo.name) {
              const label = callInfo.args ? `${callInfo.name}(${callInfo.args})` : `${callInfo.name}()`;
              const callId = flow.addAction(callExpr, label);
              flow.link(last, callId);
              last = callId;
              processedNodes.add(node);
              continue;
            }
          }
        }
      } catch (e) {
        // skip malformed node safely
      }
    }
  
    // Create end node and finalize all connections
    const end = flow.addEnd();
    if (last !== start) {
      flow.link(last, end);
    } else {
      flow.link(start, end);
    }
    flow.finalize(end);
    
    return flow.toString();
  } catch (error) {
    console.error('Error in common flowchart generation:', error);
    return 'flowchart TD\nA([start])\nB([end])\nA --> B';
  }
}
